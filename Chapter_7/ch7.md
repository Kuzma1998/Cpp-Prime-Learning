<!--
 * @Description: 
 * @code: 
 * @Author: Li Jiaxin
 * @Date: 2021-12-31 08:44:48
-->

# 类 (Class)

## 定义抽象数据类型

- **类的基本思想**:**数据抽象**(data abstraction)和**封装**。
- **数据抽象**：依赖于各种**接口**和**实现**分离编程靠技术。
- **成员函数**：定义为类的一部分的函数，也叫做**方法**。

### 类成员 (Member)

- 必须在类内进行声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- - `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
  - `return *this;`然会指向成员函数的对象，可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址），因此我们不能把`this`绑定到常量对象上（不能用常量初始化变量）。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址），可以绑定到常量也可以变量（可以用变量初始化常量）
- 常量成员函数不能改变它调用对象的内容，常量对象，常量对象的引用以及指针只可以调用常量成员函数。

```c++
total.isbn();// 相当于Sales_data::isbn(Sales_data* const)，返回total的bookNo
string isbn() const {return bookNo;} 
//相当于string isbn(const Sales_data* const)
```

### 类的作用域

- 类本身就是一个作用域，成员函数定义嵌套在类的作用域之内
- 即便bookNo定义在isbn()之后，isbn()还是可以调用；因为编译器分两步编译处理类，先编译成员的声明，然后才轮到函数体，因此成员函数体可以随意使用类内的成员。

### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。
- IO类属于不能被拷贝的类型，只能通过引用来传递。

### 类的构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫**构造函数**，只要类的对象被创建，就会执行构造函数。
- **构造函数**不能被声明成const

#### 默认构造函数

- 类通过一个特殊的默认构造函数来控制默认初始化过程，叫默认构造函数，无需任何实参。
- - 编译器创建的默认构造函数叫合成默认构造函数，初始化数据成员的规则如下：
  - 如果存在类内初值，用它来初始化成员。
  - 否则，默认初始化该成员。
-  与类同名的成员函数。
- `=default`要求编译器合成默认的构造函数。(`C++11`)，定义在内部，该函数时内联的；外部则不是。
- 构造函数放在类的`public`部分。
- 构造函数初始值列表

```c++
Sales_data(const string& s): bookNo(s){}
Sales_data(const string& s,unsigned n,double p): bookNo(s),units_sold(n),revenue(p*n) {}

//第一个构造函数用s初始化bookNo，其他参数以默认构造函数相同的方式隐式初始化
// 
```

### 拷贝、复制、析构

- 我们使用了赋值运算符，发生对象的赋值操作，如果我们未定义这些操作，编译器会帮我们合成，当然某些时刻合成的版本无法work

```c++
total = trans;
```

## 控制访问和封装

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

### 友元

- 允许特定的**非成员函数**访问一个类的**私有成员**.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 通常将友元声明成组地放在**类定义的开始或者结尾**。
- 友元声明只能在类的内部
- 类之间的友元：
    - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。
- 友元声明仅仅指定了访问权限，而不是一个函数声明，用户能够调用该友元函数还要再声明一次。


## 类的其他特性

- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。
- 成员函数可以重载。
- **可变数据成员** （mutable data member）：
  - 在变量声明前加一个`mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。因此一个const成员函数可以修改一个mutable变量的值
- **类类型**：
  - 每个类定义了唯一的类型。
  - 类的声明
  
```C++11
class Screen; //类的声明，声明之后定义之前时不完全的类型
```
- **类数据成员的初始值** 
  - 类内初始值必须用=初始化或者用花括号括起来的直接初始化。

```C++
// 类内初始值用于初始化成员函数
// 无类内，默认初始化
// 类内初始值初始化只能用=or{}
```


### 友元再探

- 可以把其他类的成员函数定义成友元
- 友元函数定义在内部时隐式内联的
- 指定了一个友元类，友元类的成员函数可以访问此类的所有成员
- 友元不存在传递性

## 类的作用域

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外

**类的定义分两步处理**：
  - 编译成员的声明
  - 直到类全部可见之后才编译函数体
  - 类声明中使用的名字，包括返回类型、参数列表等使用的名字，现在类中查找，没找到再去定义类的作用域查找。

- 一般来说内层作用域可以重新定义外层作用域的名字
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。

**成员函数使用的名字按照如下方式解析**：

- 首先在成员函数内部查找改名字的声明,只有函数使用之前出现的声明才被考虑

```C++
void func(){
    int x=4;
    cout<<y<<endl;//只能使用这句话之前的声明
    int y =4;
}
```

- 成员函数没找到，类内继续找
- 类内没有找到，成员函数定义之前的作用域找

```c++
int height;
class Screen{
public:
    typedef std::string::size_type pos;
    void dummy_fcn(pos height){
        cursor = width * height;// 使用的是传进来的参数的height,隐藏了成员height
    }
private:
    pos cursor = 0;
    pos height = 0,width=0;// 隐藏了最为外层的height
};

void Screen::dummy_fcn(pos height){
    // cursor = width * this->height;
    // cursor = width * Screen::height; //使用成员height

    cursor = width * ::height;// 使用最外部的height
}
```

## 构造函数再探

- 构造函数初始值列表：
  - 类似`python`使用赋值的方式有时候不行，比如`const`或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）
  - 最好让构造函数初始值的顺序和成员声明的顺序保持一致。
  - 如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。
  
```c++
class ConstRef(){
public:
    ConstRef(int i1);
private:
    int i;
    const int ci;
    int &ri;
};

ConstRef::ConstRef(int i1){
    i=i1;
    ci=i1;//错误，const不可以赋值
    ri =i;//错误，ri没被初始化
}

ConstRef::ConstRef(int i1): i(i1),ci(i1),ri(i){}//正确，显示初始化引用和const
```

- 成员初始化的顺序和他们在类定义中的顺序一样
- 默认实参和构造函数

```c++
class Sales_data{
public:
    Sales_data(string s=" "):bookNo(s) {}//该构造函数相当于默认构造函数
    Sales_data(string s,unsigned cnt,double rev):bookNo(s),units_sold(cnt),revenue(rev*cnt) {}
    Sales_data(istream& is) {read(is, *this);}
};
```

### 委托构造函数 （delegating constructor, `C++11`）

- 委托构造函数将自己的职责委托给了其他构造函数。
- 
```c++
class Sales_data{
public:
    // 非委托构造函数
    Sales_data(string s,unsigned cnt,double rev):bookNo(s),units_sold(cnt),revenue(rev*cnt) {}
    Sales_data():Sales_data("",0,0) {}//委托构造函数
};
```

```C++
Sales_data obj();// 函数声明 
Sales_data obj;// 默认初始化对象
```

### 隐式的类型转换

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。
- 编译器只会自动地执行`仅一步`类型转换。
```c++
item.combine("123");//错误，先要转换为string然后才能转成了类
item.combine(std::string("123"));// 正确。string转成类
```
- 需要多个实参的构造函数不能隐式转换
- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

### 聚合类 （aggregate class）

- 满足以下所有条件：
  - 所有成员都是`public`的。
  - 没有定义任何构造函数。
  - 没有类内初始值。
  - 没有基类，也没有`virtual`函数。
- 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。

### 字面值常量类

- `constexpr`函数的参数和返回值必须是字面值。
- **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
- 数据成员都是字面值类型的聚合类是字面值常量类。
- 如果不是聚合类，则必须满足下面所有条件：
  - 数据成员都必须是字面值类型。
  - 类必须至少含有一个`constexpr`构造函数。
  - 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

## 类的静态成员

- 非`static`数据成员存在于类类型的每个对象中。
- `static`数据成员独立于该类的任意对象而存在。
- 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。

- 类的静态成员存在任何对象之外，对象不包含任何与静态成员相关的数据，所有类对象只存在一个静态对象且该对象被所有的对象共享
- 静态成员函数也不与任何对象绑定，不包含this指针，不能声明为const
  
- 声明：
  - 声明之前加上关键词`static`。
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
- 定义：
  - 在类外部定义时不用加`static`。
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义，则要求必须是字面值常量类型的`constexpr`。
  
