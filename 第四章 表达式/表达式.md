<!--
 * @Descripttion: 
 * @version: 
 * @Author: Li Jiaxin
 * @Date: 2021-09-22 20:02:23
 * @LastEditors: Li Jiaxin
 * @LastEditTime: 2021-09-25 12:41:15
-->
# 第四章 表达式

&ensp;&ensp;表达式由一个或多个运算对象最初，对其求值得到一个结果。

## 表达式基础
- c++定义了一元运算符和二元运算符。
- 小整数数类型如```bool char short```通常会被提升为大整数类型如```int```。
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
    - C中原意：左值**可以**在表达式左边，右值不能。
    - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
    - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。

### 用到左值的运算符
- 赋值运算符需要一个非常量的左值作为其左侧的运算对象，结果也算一个左值。
- 取地址符&，作用于一个左值对象，返回一个右值。
- 内置解引用运算符，下标运算符，迭代器解引用运算符，string与vector的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值对象，前置版本所得结果仍是左值。
- decltype 作用于一个表达式，若表达式是左值，将会得到一个引用。
```cpp
int *p = &a;
decltype(*p);//返回int&
decltype(&p);// 返回int**
```
### 优先级与结合律
&ensp;&ensp;要注意运算符的优先级。  
&ensp;&ensp;括号无视优先级和结合律。  
&ensp;&ensp;cpp prime 147 有所有运算符的优先级。

### 求值顺序
&ensp;&ensp;优先级规定运算对象的组合顺序，但未说明运算对象的求值顺序。
```cpp
int i = f1()*f2();//f1和f2的调用顺序未知
int i=0;
cout<<i<<" "<<++i<<endl;//不知道是先++i还是先输出i再++i
```
&ensp;&ensp;四种规定运算对象的求值顺序，```&& || ?: ,```
- 某几个函数影响同一个对象，则他是一条错误的语句。


## 算术运算符
&ensp;&ensp;算术运算符的对象和结果都是右值
- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。
- 算术运算符满足左结合律（从左向右），优先级```正负>乘除余>加减```
```cpp
short short_value = 32676;
short_value = short_value+1;
cout<<short_value<<endl;//结果为-32768，+1之后符号位变成负数
//%运算符的对象都是整数类型！
//c++11 规定商一律向0去整
```


## 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。



## 赋值运算符
- 赋值运算符的左侧对象必须是一个可修改的左值
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
```cpp
//列表初始化不会进行转换，存在信息丢失风险
int i =3.11;//正确
int j = {3.11};//错误
```
- 赋值运算符满足右结合律，这点和其他二元运算符不一样。 
```cpp
ival = jval = 0;`等价于`ival = (jval = 0);
string s1,s2;
s1 = s2 = "ok";//s1,s2等于ok，去掉末尾的结束符'\0'。
```
- 赋值运算优先级比较低。
- 复合赋值运算符：```如+=,-=等等```



## 递增递减运算符
```cpp
int i=0,j;
j=++i;// j=1,i=1
j=i++;// j=1,i=2
// 两种运算符都必须作用于左值运算对象，前置版本把对象+1再返回对象本身。
//后置则将原始对象的副本作为右值返回，再把对象+1。
```

## 成员访问运算符
&ensp;&ensp;```.```运算符和```->```都可以用于访问成员。
```cpp
string s1="asdad",*p = &s1;
p->mem等价于(*p).mem;
//注意，解引用优先级小于.因此要加括号。
```
- ```->```作用于指针，结果是左值。
- ```.``` 如成员所属对象是左值，则结果是左值；若成员所属对象是右值，则结果是右值。


## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

## 位运算符

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）、与（`&`）、或（`|`）、异或（`^`）

## sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。返回的类型是 `size_t`。
- 两种形式： `sizeof (type)`和 `sizeof expr`。
- 右结合律，`sizeof *p等价于sizeof(*p)`即使p是个无效指针也不会出错，因为sizeof并没有真正使用解引用，不需要解引用就可以知道所指类型;
- sizeof(char) 结果为1。
- sizeof 引用得到被引用对象空间的大小。
- sizeof 指针 得到指针本身的大小。
- 对解引用执行sizeof，不需要指针有效。
- sizeof 数组名----得到整个数组所占空间大小。sizeof不把数组名当成指针。
- 对string与vector对象执行sizeof，只返回该类型固定部分大小，不计算对象的元素占用了多少空间。是固定值。
```cpp
    vector<int> a = {1};
    cout<<sizeof(a)<<endl;// 24
//     这是因为 vector 是C++标准库中的容器类，
//     其可以理解为一个动态数组，其内部实现有三个指针：
//     pointer _M_start;
// pointer _M_finish;
// pointer _M_end_of_storage;
    string s;
    cout<<sizeof(s)<<endl;//32
```

```cpp
//64位机器
cout << sizeof(int) << endl;//4
cout << sizeof(char) << endl;//1
cout << sizeof(double) << endl;//8
cout << sizeof(float) << endl;//4
cout << sizeof(bool) << endl;//1
cout<<sizeof(int*)<<endl;//8
```
- cout<<字符数组名 得到字符串
- cout<<普通数组名 地址
- cout<<*数组名 首元素


## 逗号运算符
&ensp;&ensp;`,`逗号运算符含有两个对象，按照从左到右的顺序求值。对于`,`来说，先对左侧表达式进行求值，然后将求值结果扔掉，`,`运算符真正的结果是右侧表达式的值，若右侧表达式的值是左值，那么最终的结果也算左值。

## 类型转换

### 算术转换
&ensp;&ensp;含义是把一种算术类型转换为另一种算术类型。
- 如果一个运算对象的类型是long double，那么无论另外一个对象的运算类型是啥，都会转成long double。
- 表达式既有浮点型，也有整数型，整数值将转换成对应的浮点类型。
- 一个对象是无符号类型，另一个对象是带符号类型且无符号类型不小于带符号类型，则带符号转换成无符号类型。
- 带符号类型大于无符号类型，若无符号类型的所有值都能存在带符号类型中，则无符号类型对象转换成带符号类型。如果不能，则带符号对象转换成无符号类型。

### 隐式类型转换

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 数组名转换为指针(decltype，&，sizeof，typeid除外)
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时。

### 显式类型转换（尽量避免）

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`
- **dynamic_cast**：支持运行时类型识别。
- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`
- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。
- `顶层const`：指针本身是个常量。
- `底层const`：指针指向是个常量。
 