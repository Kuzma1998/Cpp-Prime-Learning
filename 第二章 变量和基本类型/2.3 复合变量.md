# 复合变量
## 左值与右值
- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。

## 引用
&ensp;&ensp;`引用 `：就是给对象起别名，将变量声明符写前面加上&就是引用，如&d；  定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

## 指针
&ensp;&ensp;指针：是指向另外一种类型的复合类型,。
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。
- 指针的值的四种状态：
1. 指向一个对象；
2. 指向紧邻对象的下一个位置；
3. 空指针；
4. 无效指针。
- 指针访问对象： `cout << *p;`，`*p就是指针指向的对象`, `*`是**解引用符**。
- 空指针不指向任何对象。
- `void*`指针可以存放**任意**对象的地址。
- 其他指针类型必须要与所指对象**严格匹配**。
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：初始化所有指针。

### 空指针
&ensp;&ensp;`空指针`：不指向任何对象；
```CPP
// 生成空指针的方法:
int *p1 = nullptr;
int *p1 = 0;
int *p1 = NULL;
```

### 赋值和指针
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是`引用本身并非一个对象`。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。
```cpp
// 指针的一些操作
int i = 42; 
int *pi = 0; 
int *pi2 = &i; 
int *pi3;
// pi被初始化，但没有指向任何对象
// pi2被初始化，存有i的地址
//如果pi3定义于块内，则pi3的值是无法确定的
pi3 = pi2; 
pi2 = 0;
// pi3和pi2指向同一个对象i 
//现在pi2不指向任何对象了
pi = &ival; // pi的值被改变，现在pi 4旨向了 ival
*pi = 0; // ival的值被改变，指针pi并没有改变

```
### void*指针

void* 是一种特殊类型的指针，可以用来存放任意对象的地址。但以void*的视角来看内存空间也就仅仅是内存空间，不能访问内存空间的对象。

## 理解复合类型声明
```cpp
int* p; //合法但是容易产生误导
//  int与*相连，我们会以为基本数据类型是int*，其实仍然是int
int* pl, p2; // pl是指向int的指针，p2是int

// 另一种写法 *修饰符与变量标识符写在一起，强调复合类型
int *pl, *p2; // pl和p2都是指向int的指针
```
指针的指针：通过*的个数可以区分指针的级別。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推：
```CPP
int ival = 1024;
int *pi = &ival; // pi 指向一个 int 型的数
int **ppi = &pi; // ppi指向一个int型的指针

cout <<"The value of ival\n"
<<"direct value: " <<ival <<"\n" 
<<"indirect value: " <<*pi <<"\n" //解引用指针 得到对象
<< "doubly indirect value: " << **ppi << endl;
// 解引用一次得到*p，int 类型的指针，再解引用得到对象
```
```cpp
//引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

int i = 42;
int *p; // p是一个int型指针
int *&r = p; // r是一个对指针p的引用 &说明r是引用,其余部分*修饰引用，这个引用指向一个指针，int代表是一个整型指针
r = &i; // r引用了一个指针，因此给r賦值&i就是令p指向i，r就是指向i的指针
*r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0
```





