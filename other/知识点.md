<!--
 * @Description: 
 * @code: 
 * @Author: Li Jiaxin
 * @Date: 2021-12-17 11:02:13
-->

## 构造函数
```c++
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造
默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。

#include<iostream>
using namespace std;


class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	Person(p3); // 此代码错误
}

int main() {

	// test01();
	test02();

	// system("pause");

	return 0;
}
```

## 浅拷贝
- 简单的赋值操作

## 深拷贝
- 在堆区申请一块空间，进行拷贝操作
- 类有属性指向堆区，会有深浅拷贝的问题，因为不能释放一个内存两次

## 函数指针
**未完成**

```c++
#include<iostream>
#include <queue>
#include<vector>
#include<algorithm>
using namespace std;

bool compare(int a,int b){
    return a>b;
}
int main() 
{
    //对于基础类型 默认是大顶堆
    priority_queue<int> a; 
    //等同于 priority_queue<int, vector<int>, less<int> > a;
    
  
    priority_queue<int, vector<int>, greater<int>> c;  //这样就是小顶堆 // 类模板填入类型名
    // priority_queue<int, vector<int>, decltype(compare)*> c;
    priority_queue<string> b;
    
    for (int i = 0; i < 5; i++) 
    {
        a.push(i);
        c.push(i);
    }
    while (!a.empty()) 
    {
        cout << a.top() << ' ';
        a.pop();
    } 
    cout << endl;

    while (!c.empty()) 
    {
        cout << c.top() << ' ';
        c.pop();
    }
    cout << endl;

    b.push("abc");
    b.push("abcd");
    b.push("cbd");
    while (!b.empty()) 
    {
        cout << b.top() << ' ';
        b.pop();
    } 
    cout << endl;
    cout<< "******************"<< endl;

    vector<int> ljx{77,22,44,66,88,11};
    sort(ljx.begin(), ljx.end(),greater<int>());//函数模板填入一个具体的类对象或者函数名字，比如定义了一个comp函数只填入comp，不带括号
    // sort(ljx.begin(), ljx.end(),compare);// 传入一个可调用的对象，lambda，函数，函数指针，重载了（）运算符的类,不允许使用类型名
    // bool (*pf)(int a, int b) = compare;
    // sort(ljx.begin(), ljx.end(),pf);
    for(auto i:ljx)
        cout<<i<<endl;
    return 0;
}

```

## 内存分区
 **c++不可以返回局部对象的引用和指针，但是可以返回拷贝，总结就是局部变量定义在栈区，不可以返回栈区的东西，函数结束就销毁了**

# 1 内存分区模型

C++程序在执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

**内存四区意义**：

不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程

## 1.1 程序运行前
​在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

**代码区**：
- 存放 CPU 执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在- 内存中有一份代码即可
代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令

​**全局区**：

- 全局变量和静态变量存放在此.
- 全局区还包含了常量区, 字符串常量和其他常量也存放在此​
- 该区域的数据在程序结束后由操作系统释放.


**总结**
- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放全局变量、静态变量、常量
- 常量区中存放 const修饰的全局常量 和 字符串常量


## 1.2 程序运行后
**栈区**：
- 由编译器自动分配释放, 存放函数的参数值,局部变量等
- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆区**：
- 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收
- 在C++中主要利用new在堆区开辟内存

**总结**：
- 堆区数据由程序员管理开辟和释放
- 堆区数据利用new关键字进行开辟内存


# 2 静态变量和静态函数

## 全局变量静态（static）
- 1）内存中的位置：静态存储区（静态存储区在整个程序运行期间存在）；
- 2）初始化：未经初始化的静态全局变量会被程序自动初始化为0，普通全局变量未经初始化的值是任意的；
- 3）作用域：全局静态变量的只在声明它的文件下是可见的（从定义到文件结尾），普通全局变量在整个工程中是可见的。
- 优点：1）不会被其他文件访问和修改；2）其他文件使用相同的名字的变量不会发生冲突

## 静态函数
静态函数

函数的定义和声明默认情况下是extern的，但静态函数只在声明他的文件当中可见，不能被其他文件所用，

- 1）静态函数在其他文件中科技定义形同的名字，不会发生冲突；

- 2）静态函数不能被其他文件所用；

- 3）静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。

## 总结

- <1>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

- <2>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；

- <3>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

- <4>类里面的static 成员要在类外初始化（定义），类内声明，常量类成员可以类内初始化
- <5>静态成员函数通过类名调用，或者显示的指出某个类的地址调用

## C++编译过程
编译过程分为四个过程：**预处理（预编译）、编译和优化、汇编和链接**。
<img src="https://pic.leetcode-cn.com/1612676946-HVvkdR-image.png" alt="image.png" style="zoom:50%;" />

## 预处理
**预处理**：在这个阶段主要是对伪指令和特殊符合进行处理。

```C++
//伪指令主要包括以下四个方面：
(1)宏定义指令，如# define Name TokenString，# undef等,在处理过程中需要将Name用TokenString替换，但作为字符串常量的 Name则不被替换。
(2)条件编译指令，如# ifdef，# ifndef，# else，# elif，# endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。
(3)头文件包含指令，如# include "FileName" 或者# include < FileName> 等。在头文件中一般用伪指令# define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条# include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。
//特殊符号
如INT_MIN和INT_MAX 预编译程序对于在源程序中出现的这些串将用合适的值进行替换。  
```

## 编译、优化阶段

**编译、优化阶段**：经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

## 汇编
**汇编**：汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

```C++
目标文件由段组成。通常一个目标文件中至少有两个段：
1) 代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
2) 数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。
```

## 链接
**链接**：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

```C++
链接分为两种：
//静态链接
静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

//动态链接
    动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

    共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

    更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
    
    性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。
```

## 代码举例

```C++
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Solution
{
public:
    int findContentChildren(vector<int> &g, vector<int> &s)
    {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end(), [](int a, int b)
             { return a > b; });
        int j = 0;
        int ans = 0;
        for (int i =s.size()-1; i >=0; --i)
        {
            if (j == g.size())
                break;
            if (s[i] >= g[j])
            {
                ++ans;
                ++j;
            }
        }
        return ans;
    }
};

int main(){
    vector<int> g = {10,9,8,7};
    vector<int> s = {5,6,7,8};
    Solution solver;
    cout<<solver.findContentChildren(g,s)<<endl;

g++ test.cpp -o test // 直接编译链接生成可执行文件test
g++ test.cpp // 默认生成a.out

// 分步执行
./a.out || test //执行文件
g++ -E test.cpp > test.i // 预处理生成test.i文件
g++ -S test.i // 预处理文件test.i生成test.s文件，汇编指令
g++ -c test.s// 汇编，把汇编代码test.s汇编成二进制机器码test.o
g++ test.o -o test.exe// 链接成为可执行文件
./test.exe // 执行可执行文件

//多文件
g++ -c 1.cpp
g++ -c 2.CPP
g++ 1.o 2.o -o test.exe

} 
```

## 派生类和基类的转换
**存在派生类到基类的隐式转换，即可以用基类指针和引用指向派生类**
**dynamic_cast 用于基类指针或者引用转换为派生类的指针或者引用**
