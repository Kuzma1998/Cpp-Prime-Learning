<!--
 * @Description: 
 * @code: 
 * @Author: Li Jiaxin
 * @Date: 2022-01-03 22:03:56
-->
# C++编译过程
编译过程分为四个过程：**预处理（预编译）、编译和优化、汇编和链接**。
<img src="https://pic.leetcode-cn.com/1612676946-HVvkdR-image.png" alt="image.png" style="zoom:50%;" />

## 预处理
**预处理**：在这个阶段主要是对伪指令和特殊符合进行处理。

```C++
//伪指令主要包括以下四个方面：
(1)宏定义指令，如# define Name TokenString，# undef等,在处理过程中需要将Name用TokenString替换，但作为字符串常量的 Name则不被替换。
(2)条件编译指令，如# ifdef，# ifndef，# else，# elif，# endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。
(3)头文件包含指令，如# include "FileName" 或者# include < FileName> 等。在头文件中一般用伪指令# define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条# include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。
//特殊符号
如INT_MIN和INT_MAX 预编译程序对于在源程序中出现的这些串将用合适的值进行替换。  
```

## 编译、优化阶段

**编译、优化阶段**：经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

## 汇编
**汇编**：汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

```C++
目标文件由段组成。通常一个目标文件中至少有两个段：
1) 代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
2) 数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。
```

## 链接
**链接**：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

```C++
链接分为两种：
//静态链接
静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

//动态链接
    动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

    共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

    更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
    
    性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。
```

## 代码举例

```C++
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Solution
{
public:
    int findContentChildren(vector<int> &g, vector<int> &s)
    {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end(), [](int a, int b)
             { return a > b; });
        int j = 0;
        int ans = 0;
        for (int i =s.size()-1; i >=0; --i)
        {
            if (j == g.size())
                break;
            if (s[i] >= g[j])
            {
                ++ans;
                ++j;
            }
        }
        return ans;
    }
};

int main(){
    vector<int> g = {10,9,8,7};
    vector<int> s = {5,6,7,8};
    Solution solver;
    cout<<solver.findContentChildren(g,s)<<endl;

g++ test.cpp -o test // 直接编译链接生成可执行文件test
g++ test.cpp // 默认生成a.out

// 分步执行
./a.out || test //执行文件
g++ -E test.cpp > test.i // 预处理生成test.i文件
g++ -S test.i // 预处理文件test.i生成test.s文件，汇编指令
g++ -c test.s// 汇编，把汇编代码test.s汇编成二进制机器码test.o
g++ test.o -o test.exe// 链接成为可执行文件
./test.exe // 执行可执行文件
} 
```

