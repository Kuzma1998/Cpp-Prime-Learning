# 第六章 函数

## 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
```CPP
//调用函数 int fact(int value);
首先用实参隐士地初始化它地形参
当遇到return语句时函数结束执行，与函数调用一样
return语句完成两项工作，一个是返回return语句的值
二是把控制权从被调函数转移到主函数
```
- **形参和实参**：形参和实参的**个数**和**类型**必须匹配上。可以发生隐式的转换。
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
- **名字**：名字的作用于是程序文本的一部分，名字在其中可见。
```CPP
  //数组的引用
  int (&arr)[10];
  // 引用的数组 是非法的，数组元素是引用，引用必需绑定到一个变量上，但是无法用数组进行拷贝和赋值。
  int &arr[10];
```

### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的,会隐藏外层作用域的同名的其他所有声明。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后，它只在第一定义时初始化。
- 如果**局部静态对象**没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为。
  

### 函数声明

- **函数声明**：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称**函数原型**。
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

### C++编译过程

编译过程分为四个过程：**预处理（预编译）、编译和优化、汇编和链接**。

<img src="https://pic.leetcode-cn.com/1612676946-HVvkdR-image.png" alt="image.png" style="zoom:50%;" />

**预处理：**在这个阶段主要是对伪指令和特殊符合进行处理。

```C++
//伪指令主要包括以下四个方面：
(1)宏定义指令，如# define Name TokenString，# undef等,在处理过程中需要将Name用TokenString替换，但作为字符串常量的 Name则不被替换。
(2)条件编译指令，如# ifdef，# ifndef，# else，# elif，# endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。
(3)头文件包含指令，如# include "FileName" 或者# include < FileName> 等。在头文件中一般用伪指令# define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条# include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。
//特殊符号
如INT_MIN和INT_MAX 预编译程序对于在源程序中出现的这些串将用合适的值进行替换。  
```

**编译、优化阶段：**经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

**汇编：**汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

```C++
目标文件由段组成。通常一个目标文件中至少有两个段：
1) 代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
2) 数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。
```

**链接：**汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

```C++
链接分为两种：
//静态链接
静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

//动态链接
    动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

    共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

    更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
    
    性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。
```
## 参数传递

- 每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。
- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针，通过指针也可以修改他所指对象的值。
```CPP
  void reset(int* p){
    *p = 0;
    ip = 0;
  }
  int main(){
    int i =42;
    reset(&i);// 改变i的值并非i的地址
    cout<<"i= "<<i<<endl;// i=0;
  }
```

### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**返回额外的信息**。
- 经常用引用形参来避免不必要的复制。
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为常量引用。

### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。
```CPP
  int i=42;
  const int *cp = &i;// 正确，但是cp不能改变i的值
  const int &r =i;//正确，可以使用非常量初始化一个底层`const`对象但是r不可以改变i
  const int &r2 = 42;// 正确，常量初始化常量
  int *p = cp;// 错误，不能用常量初始化变量
  int &r3 = r;// 错误，不可以用非常量引用绑定到常量
  int &r4 = 42;// 错误，与上方一致。
  // 可以用变量初始化常量但是不可以用常量对象初始化变量
  // 函数与上方一样
  int reset(int& r);//调用此版本的rest函数只能用int类型的对象，不能使用字面值，需要转换的对象或者const int类型;
  // 类似，调用指针版本的reset只能使用int*，不能使用
```

### 数组形参

- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- 要注意数组的实际长度，不能越界。

### main处理命令行选项

- `int main(int argc, char *argv[]){...}`
- 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。

### 可变形参

`initializer_list`提供的操作（`C++11`）：

| 操作 | 解释 |
|-----|-----|
| `initializer_list<T> lst;` | 默认初始化；`T`类型元素的空列表 |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)` | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst` | 同上 |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中微元素下一位置的指针 |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。

## 返回类型和return语句

### 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。

### 返回数组指针

- `Type (*function (parameter_list))[dimension]`
- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10;]`，然后 `arrT* func() {...}`
- 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

## 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
- `main`函数不能重载。
- **重载和const形参**：
  - 一个有顶层const的形参和没有它的函数无法区分。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
  - 相反，是否有某个底层const形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分。
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。

## 特殊用途语言特性

### 默认实参

- `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

### 内联（inline）函数

- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。

### constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型。
- `constexpr`函数应该在头文件中定义。

### 调试帮助

- `assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

## 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

## 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。
